#!/usr/bin/env python3
"""
eMISTR MCP Server
Provides AI assistants access to eMISTR ERP via MCP protocol
"""

import asyncio
import json
import logging
from typing import Any, Sequence, Mapping, List
from mcp.server import Server
from mcp.types import Tool, TextContent
from aiohttp import web

from database import DatabaseManager
from anonymizer import DataAnonymizer
from response_builder import ResponseBuilder
from config import Config

# Logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger('emistr-mcp')

# MCP server instance (decorators use this)
app = Server("emistr-mcp")

# Globals
config: Config = None
_db: DatabaseManager = None
_anonymizer: DataAnonymizer = None
_response_builder: ResponseBuilder = None


async def initialize() -> None:
    """Initialize configuration, database and helpers."""
    global config, _db, _anonymizer, _response_builder

    config = Config()
    _db = DatabaseManager(config)
    _anonymizer = DataAnonymizer(config)
    _response_builder = ResponseBuilder()

    await _db.connect()
    logger.info("eMISTR MCP Server initialized")


@app.list_tools()
async def list_tools() -> List[Tool]:
    """Return the list of available tools (partial definitions)."""
    return [
        Tool(name="get_orders", description="Získá seznam zakázek.", inputSchema={"type": "object"}),
        Tool(name="get_order_detail", description="Získá detail zakázky.", inputSchema={"type": "object"}),
    ]


def _redact_arguments(arguments: Any) -> str:
    """Return a short, non-sensitive representation of arguments for logs."""
    try:
        if isinstance(arguments, Mapping):
            # show keys and value types only
            return ",".join(f"{k}={type(v).__name__}" for k, v in arguments.items())
        return type(arguments).__name__
    except Exception:
        return "<unavailable>"


def _get_client_ip(request: web.Request) -> str:
    """Extract client IP address safely."""
    try:
        if request.remote:
            return request.remote
        if request.transport:
            peer = request.transport.get_extra_info('peername')
            if peer:
                return peer[0]
    except Exception:
        pass
    return "unknown"


@app.call_tool()
async def call_tool(name: str, arguments: Any) -> Sequence[Any]:
    """Process a tool call (dispatcher)."""
    try:
        logger.info("Tool called: %s args_summary: %s", name, _redact_arguments(arguments))

        if name == "get_orders":
            result = await _db.get_orders(**arguments)
            anonymized = _anonymizer.anonymize_orders(result)
            response = _response_builder.build_orders_response(anonymized, arguments)

        elif name == "get_order_detail":
            result = await _db.get_order_detail(**arguments)
            anonymized = _anonymizer.anonymize_order_detail(result)
            response = _response_builder.build_order_detail_response(anonymized)

        else:
            response = {"status": "error", "message": f"Neznámý tool: {name}"}

        return [TextContent(type="text", text=json.dumps(response, ensure_ascii=False))]

    except Exception:
        logger.exception("Error in tool %s", name)
        error_response = {"status": "error", "message": "Chyba při zpracování"}
        return [TextContent(type="text", text=json.dumps(error_response, ensure_ascii=False))]


async def mcp_handler(request: web.Request):
    """HTTP handler for MCP tool calls."""
    client_ip = _get_client_ip(request)

    # Validate content type
    content_type = (request.content_type or '').lower()
    if 'application/json' not in content_type:
        msg = "Unsupported Media Type: application/json required"
        logger.warning("MCP HTTP call from %s: %s (Content-Type: %s)", client_ip, msg, content_type)
        return web.json_response({"status": "error", "message": msg}, status=415)

    # Parse JSON body
    try:
        payload = await request.json()
    except Exception:
        logger.warning("MCP HTTP call from %s: malformed JSON payload", client_ip)
        return web.json_response({"status": "error", "message": "Malformed JSON payload"}, status=400)

    if not isinstance(payload, dict):
        logger.warning("MCP HTTP call from %s: JSON payload is not an object", client_ip)
        return web.json_response({"status": "error", "message": "JSON payload must be an object"}, status=400)

    tool_name = payload.get('name')
    tool_arguments = payload.get('arguments')

    if not tool_name or tool_arguments is None:
        logger.warning("Invalid MCP request from %s: missing 'name' or 'arguments' - keys: %s", client_ip, list(payload.keys()))
        return web.json_response({"status": "error", "message": "Missing 'name' or 'arguments' in request payload"}, status=400)

    if not isinstance(tool_arguments, Mapping):
        logger.warning("Invalid MCP request from %s: 'arguments' must be an object, got %s", client_ip, type(tool_arguments).__name__)
        return web.json_response({"status": "error", "message": "'arguments' must be an object/dictionary"}, status=400)

    logger.info("MCP HTTP call received from %s: %s args_summary: %s", client_ip, tool_name, _redact_arguments(tool_arguments))

    try:
        result_contents = await call_tool(tool_name, tool_arguments)
    except Exception:
        logger.exception("Error while executing tool %s", tool_name)
        return web.json_response({"status": "error", "message": "Internal server error"}, status=500)

    # Extract primary response
    response_data: Any = None
    if result_contents:
        first = result_contents[0]
        if isinstance(first, TextContent):
            try:
                response_data = json.loads(first.text)
            except Exception:
                response_data = first.text
        else:
            response_data = {"type": getattr(first, 'type', 'unknown')}

    return web.json_response(response_data if response_data is not None else {}, status=200)


async def health_handler(request: web.Request):
    return web.json_response({"status": "ok"}, status=200)


async def main() -> None:
    await initialize()

    web_app = web.Application()
    web_app.router.add_get('/health', health_handler)
    web_app.router.add_post('/mcp', mcp_handler)

    runner = web.AppRunner(web_app)
    await runner.setup()
    site = web.TCPSite(runner, host='0.0.0.0', port=9001)
    await site.start()

    logger.info("eMISTR MCP HTTP Server started on port 9001")

    try:
        while True:
            await asyncio.sleep(3600)
    except asyncio.CancelledError:
        logger.info("Shutdown requested, stopping server")
    finally:
        # Attempt DB disconnect
        try:
            disconnect = getattr(_db, 'disconnect', None)
            if disconnect:
                await disconnect()
        except Exception:
            logger.exception("Error while disconnecting DB")
        await runner.cleanup()


if __name__ == "__main__":
    asyncio.run(main())
