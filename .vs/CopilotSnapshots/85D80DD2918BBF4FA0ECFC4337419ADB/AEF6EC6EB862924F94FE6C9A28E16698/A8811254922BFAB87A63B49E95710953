#!/usr/bin/env python3
"""
eMISTR MCP Server
Poskytuje AI asistentům přístup k eMISTR ERP systému přes MCP protokol
"""

import asyncio
import json
import logging
from typing import Any, Sequence, Mapping, List
from mcp.server import Server
from mcp.types import (
 Tool,
 TextContent,
 ImageContent,
 EmbeddedResource,
)
from aiohttp import web

from database import DatabaseManager
from anonymizer import DataAnonymizer
from response_builder import ResponseBuilder
from config import Config

# Nastavení logování
logging.basicConfig(
 level=logging.INFO,
 format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger('emistr-mcp')

# Inicializace serveru
app = Server("emistr-mcp")

# Globální instance
config: Config = None
_db: DatabaseManager = None
_anonymizer: DataAnonymizer = None
_response_builder: ResponseBuilder = None


async def initialize() -> None:
 """Inicializace serveru a připojení k databázi"""
 global config, _db, _anonymizer, _response_builder

 config = Config()
 _db = DatabaseManager(config)
 _anonymizer = DataAnonymizer(config)
 _response_builder = ResponseBuilder()

 await _db.connect()
 logger.info("eMISTR MCP Server initialized")


@app.list_tools()
async def list_tools() -> List[Tool]:
 """Vrátí seznam dostupných tools"""
 return [
 Tool(
 name="get_orders",
 description="""
 Získá seznam zakázek s možností filtrování.
 """,
 inputSchema={
 "type": "object",
 "properties": {
 "status": {"type": "string", "enum": ["ANO", "NE", ""]},
 "customer_id": {"type": "integer"},
 "date_from": {"type": "string"},
 "date_to": {"type": "string"},
 "limit": {"type": "integer", "default":50},
 },
 },
 ),
 Tool(
 name="get_order_detail",
 description="""
 Získá detailní informace o konkrétní zakázce včetně operací, materiálu a dokumentů.
 """,
 inputSchema={"type": "object", "properties": {"order_id": {"type": "integer"}, "order_code": {"type": "string"}}},
 ),
 Tool(
 name="search_orders",
 description="Fulltextové vyhledávání v zakázkách",
 inputSchema={"type": "object", "properties": {"search_term": {"type": "string"}, "limit": {"type": "integer", "default":20}}, "required": ["search_term"]},
 ),
 Tool(
 name="get_workers",
 description="Seznam zaměstnanců",
 inputSchema={"type": "object", "properties": {"status": {"type": "string", "enum": ["ANO", "NE", ""]}, "group_name": {"type": "string"}, "limit": {"type": "integer", "default":50}}},
 ),
 Tool(
 name="get_worker_detail",
 description="Detail zaměstnance",
 inputSchema={"type": "object", "properties": {"worker_id": {"type": "integer"}}, "required": ["worker_id"]},
 ),
 Tool(
 name="get_materials",
 description="Seznam materiálů na skladu",
 inputSchema={"type": "object", "properties": {"sklad_id": {"type": "integer"}, "low_stock_only": {"type": "boolean", "default": False}, "limit": {"type": "integer", "default":50}}},
 ),
 Tool(
 name="get_material_movements",
 description="Pohyby materiálu",
 inputSchema={"type": "object", "properties": {"material_id": {"type": "integer"}, "date_from": {"type": "string"}, "date_to": {"type": "string"}, "limit": {"type": "integer", "default":100}}},
 ),
 Tool(
 name="get_operations",
 description="Seznam operací",
 inputSchema={"type": "object", "properties": {"operation_group": {"type": "string"}, "limit": {"type": "integer", "default":50}}},
 ),
 Tool(
 name="get_machines",
 description="Seznam strojů",
 inputSchema={"type": "object", "properties": {"status_filter": {"type": "string"}, "limit": {"type": "integer", "default":50}}},
 ),
 Tool(
 name="get_production_stats",
 description="Statistiky výroby",
 inputSchema={"type": "object", "properties": {"date_from": {"type": "string"}, "date_to": {"type": "string"}}, "required": ["date_from", "date_to"]},
 ),
 ]


def _redact_arguments(arguments: Any) -> str:
 """Return a short, non-sensitive representation of arguments for logs."""
 try:
 if isinstance(arguments, Mapping):
 # show keys and value types only
 return ",".join(f"{k}={type(v).__name__}" for k, v in arguments.items())
 return type(arguments).__name__
 except Exception:
 return "<unavailable>"


def _get_client_ip(request: web.Request) -> str:
 try:
 if request.remote:
 return request.remote
 peer = request.transport.get_extra_info('peername') if request.transport else None
 if peer:
 return peer[0]
 except Exception:
 pass
 return "unknown"


@app.call_tool()
async def call_tool(name: str, arguments: Any) -> Sequence[TextContent | ImageContent | EmbeddedResource]:
 """Zpracování volání tools"""
 try:
 # Log name and a redacted summary of arguments to avoid PII in logs
 logger.info(f"Tool called: {name} args_summary: {_redact_arguments(arguments)}")

 # Dispatch to DB functions
 if name == "get_orders":
 result = await _db.get_orders(**arguments)
 anonymized = _anonymizer.anonymize_orders(result)
 response = _response_builder.build_orders_response(anonymized, arguments)

 elif name == "get_order_detail":
 result = await _db.get_order_detail(**arguments)
 anonymized = _anonymizer.anonymize_order_detail(result)
 response = _response_builder.build_order_detail_response(anonymized)

 elif name == "search_orders":
 result = await _db.search_orders(**arguments)
 anonymized = _anonymizer.anonymize_orders(result)
 response = _response_builder.build_search_response(anonymized, arguments)

 elif name == "get_workers":
 result = await _db.get_workers(**arguments)
 anonymized = _anonymizer.anonymize_workers(result)
 response = _response_builder.build_workers_response(anonymized, arguments)

 elif name == "get_worker_detail":
 result = await _db.get_worker_detail(**arguments)
 anonymized = _anonymizer.anonymize_worker_detail(result)
 response = _response_builder.build_worker_detail_response(anonymized)

 elif name == "get_materials":
 result = await _db.get_materials(**arguments)
 response = _response_builder.build_materials_response(result, arguments)

 elif name == "get_material_movements":
 result = await _db.get_material_movements(**arguments)
 response = _response_builder.build_movements_response(result, arguments)

 elif name == "get_operations":
 result = await _db.get_operations(**arguments)
 response = _response_builder.build_operations_response(result, arguments)

 elif name == "get_machines":
 result = await _db.get_machines(**arguments)
 response = _response_builder.build_machines_response(result, arguments)

 elif name == "get_production_stats":
 result = await _db.get_production_stats(**arguments)
 response = _response_builder.build_stats_response(result, arguments)

 else:
 response = {"status": "error", "message": f"Neznámý tool: {name}"}

 # Return response as JSON text
 return [TextContent(type="text", text=json.dumps(response, ensure_ascii=False, indent=2))]

 except Exception as e:
 logger.error(f"Error in tool {name}: {str(e)}", exc_info=True)
 error_response = {
 "status": "error",
 "message": f"Chyba při zpracování: {str(e)}",
 "action": {"type": "show_message", "message": "Došlo k chybě při načítání dat"},
 }
 return [TextContent(type="text", text=json.dumps(error_response, ensure_ascii=False, indent=2))]


async def mcp_handler(request: web.Request):
 """HTTP handler for MCP tool calls"""
 client_ip = _get_client_ip(request)
 try:
 # Require JSON
 content_type = request.content_type or ''
 if 'application/json' not in content_type:
 msg = "Unsupported Media Type: application/json required"
 logger.warning(f"MCP HTTP call from {client_ip}: {msg} (Content-Type: {content_type})")
 return web.json_response({"status": "error", "message": msg}, status=415)

 try:
 payload = await request.json()
 except Exception:
 logger.warning(f"MCP HTTP call from {client_ip}: malformed JSON payload", exc_info=False)
 return web.json_response({"status": "error", "message": "Malformed JSON payload"}, status=400)

 # Expecting a JSON object
 if not isinstance(payload, dict):
 logger.warning(f"MCP HTTP call from {client_ip}: JSON payload is not an object")
 return web.json_response({"status": "error", "message": "JSON payload must be an object"}, status=400)

 tool_name = payload.get('name')
 tool_arguments = payload.get('arguments')

 if not tool_name or tool_arguments is None:
 logger.warning(
 f"Invalid MCP request from {client_ip}: missing 'name' or 'arguments' - payload keys: {list(payload.keys())}"
 )
 return web.json_response({"status": "error", "message": "Missing 'name' or 'arguments' in request payload"}, status=400)

 if not isinstance(tool_arguments, Mapping):
 logger.warning(
 f"Invalid MCP request from {client_ip}: 'arguments' must be an object, got {type(tool_arguments).__name__}"
 )
 return web.json_response({"status": "error", "message": "'arguments' must be an object/dictionary"}, status=400)

 logger.info(f"MCP HTTP call received from {client_ip}: {tool_name} args_summary: {_redact_arguments(tool_arguments)}")
 result_contents = await call_tool(tool_name, tool_arguments)

 # Extract data from TextContent objects
 response_data: List[Any] = []
 for content in result_contents:
 if isinstance(content, TextContent):
 try:
 json_parsed = json.loads(content.text)
 response_data.append(json_parsed)
 except json.JSONDecodeError:
 response_data.append(content.text)
 else:
 response_data.append({"type": getattr(content, 'type', 'unknown')})

 return web.json_response(response_data[0] if response_data and isinstance(response_data[0], dict) else response_data, status=200)

 except Exception as e:
 logger.error(f"Error processing MCP HTTP request from {client_ip}: {e}", exc_info=True)
 return web.json_response({"status": "error", "message": "Internal server error"}, status=500)


async def health_handler(request: web.Request):
 return web.json_response({"status": "ok"}, status=200)


async def main() -> None:
 """Hlavní funkce serveru"""
 await initialize()

 web_app = web.Application()
 web_app.router.add_get('/health', health_handler)
 web_app.router.add_post('/mcp', mcp_handler)

 runner = web.AppRunner(web_app)
 await runner.setup()
 site = web.TCPSite(runner, host='0.0.0.0', port=9001)
 await site.start()

 logger.info("eMISTR MCP HTTP Server started on port9001")

 # Keep the server running until cancelled; ensure cleanup
 try:
 while True:
 await asyncio.sleep(3600)
 except asyncio.CancelledError:
 logger.info("Shutdown requested, stopping server")
 finally:
 # try to disconnect DB if supported
 try:
 disconnect = getattr(_db, 'disconnect', None)
 if disconnect:
 await disconnect()
 except Exception:
 logger.exception("Error while disconnecting DB")
 await runner.cleanup()


if __name__ == "__main__":
 asyncio.run(main())
