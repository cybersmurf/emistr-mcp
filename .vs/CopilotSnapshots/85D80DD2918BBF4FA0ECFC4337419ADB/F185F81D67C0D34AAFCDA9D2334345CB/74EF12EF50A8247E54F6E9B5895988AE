#!/usr/bin/env python3
"""
eMISTR MCP Server
Provides AI assistants access to eMISTR ERP via MCP protocol
"""

import asyncio
import json
import logging
from typing import Any, Sequence, Mapping, List, Dict
from mcp.server import Server
from mcp.types import Tool, TextContent
from aiohttp import web

from database import DatabaseManager
from anonymizer import DataAnonymizer
from response_builder import ResponseBuilder
from config import Config

# Logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger('emistr-mcp')

# MCP server instance (decorators use this)
app = Server("emistr-mcp")

# Globals
config: Config = None
_db: DatabaseManager = None
_anonymizer: DataAnonymizer = None
_response_builder: ResponseBuilder = None


async def _get_server_offerings() -> Dict[str, Any]:
    tools_list = await list_tools()
    tools_dicts = [tool.to_dict() if hasattr(tool, 'to_dict') else tool for tool in tools_list]
    
    return {
        "protocolVersion": "2.0", # Moved back to here, at the top level of the offerings for all calls
        "capabilities": {
            "tools": {"streamable": False, "searchable": False},
            "resources": {"streamable": False, "searchable": False},
            "embedding": False
        },
        "serverInfo": {
            "name": "emistr-mcp",
            "version": "0.1.0", # Assuming a simple version for now
            "description": "eMISTR MCP Server providing access to eMISTR ERP via MCP protocol."
        },
        "tools": tools_dicts
    }


async def initialize() -> None:
    """Initialize configuration, database and helpers."""
    global config, _db, _anonymizer, _response_builder

    config = Config()
    _db = DatabaseManager(config)
    _anonymizer = DataAnonymizer(config)
    _response_builder = ResponseBuilder()

    await _db.connect()
    logger.info("eMISTR MCP Server initialized")


@app.list_tools()
async def list_tools() -> List[Tool]:
    """Return the list of available tools (partial definitions)."""
    return [
        Tool(
            name="initialize",
            description="Initializes the MCP client and returns server capabilities.",
            inputSchema={"type": "object", "properties": {}} # Minimal input schema
        ),
        Tool(
            name="get_orders",
            description="Získá seznam zakázek.",
            inputSchema={
                "type": "object",
                "properties": {
                    "limit": {"type": "integer", "description": "Maximální počet zakázek k vrácení"},
                    "offset": {"type": "integer", "description": "Počet zakázek k přeskočení"}
                }
            }
        ),
        Tool(
            name="get_order_detail",
            description="Získá detail zakázky.",
            inputSchema={
                "type": "object",
                "properties": {
                    "order_id": {"type": "string", "description": "ID zakázky"}
                },
                "required": ["order_id"]
            }
        ),
    ]


def _redact_arguments(arguments: Any) -> str:
    """Return a short, non-sensitive representation of arguments for logs."""
    try:
        if isinstance(arguments, Mapping):
            # show keys and value types only
            return ",".join(f"{k}={type(v).__name__}" for k, v in arguments.items())
        return type(arguments).__name__
    except Exception:
        return "<unavailable>"


def _get_client_ip(request: web.Request) -> str:
    """Extract client IP address safely."""
    try:
        if request.remote:
            return request.remote
        if request.transport:
            peer = request.transport.get_extra_info('peername')
            if peer:
                return peer[0]
    except Exception:
        pass
    return "unknown"


@app.call_tool()
async def call_tool(name: str, arguments: Any) -> Sequence[Any]:
    """Process a tool call (dispatcher)."""
    try:
        logger.info("Tool called: %s args_summary: %s", name, _redact_arguments(arguments))

        if name == "initialize":
            offerings = await _get_server_offerings()
            # protocolVersion is now part of offerings from _get_server_offerings
            return [TextContent(type="text", text=json.dumps(offerings, ensure_ascii=False))]

        elif name == "get_orders":
            result = await _db.get_orders(**arguments)
            anonymized = _anonymizer.anonymize_orders(result)
            response = _response_builder.build_orders_response(anonymized, arguments)

        elif name == "get_order_detail":
            result = await _db.get_order_detail(**arguments)
            anonymized = _anonymizer.anonymize_order_detail(result)
            response = _response_builder.build_order_detail_response(anonymized)

        else:
            response = {"status": "error", "message": f"Neznámý tool: {name}"}

        return [TextContent(type="text", text=json.dumps(response, ensure_ascii=False))]

    except Exception:
        logger.exception("Error in tool %s", name)
        error_response = {"status": "error", "message": "Chyba při zpracování"}
        return [TextContent(type="text", text=json.dumps(error_response, ensure_ascii=False))]


async def mcp_post_handler(request: web.Request):
    """HTTP handler for MCP tool calls."""
    client_ip = _get_client_ip(request)

    # Validate content type
    content_type = (request.content_type or '').lower()
    if 'application/json' not in content_type:
        return web.json_response(
            {"jsonrpc": "2.0", "id": None, "error": {"code": -32700, "message": "Unsupported Media Type: application/json required"}},
            status=415
        )

    # Parse JSON body
    payload_id: Any = None
    try:
        payload = await request.json()
        payload_id = payload.get('id')
    except Exception:
        logger.warning("MCP HTTP call from %s: malformed JSON payload", client_ip)
        return web.json_response(
            {"jsonrpc": "2.0", "id": None, "error": {"code": -32700, "message": "Malformed JSON payload"}},
            status=400
        )

    if not isinstance(payload, dict):
        logger.warning("MCP HTTP call from %s: JSON payload is not an object", client_ip)
        return web.json_response(
            {"jsonrpc": "2.0", "id": payload_id, "error": {"code": -32700, "message": "JSON payload must be an object"}},
            status=400
        )

    tool_name = payload.get('method') # Changed from 'name'
    tool_arguments = payload.get('params') # Changed from 'arguments'

    if not tool_name or tool_arguments is None:
        logger.warning("Invalid MCP request from %s: missing 'method' or 'params' - keys: %s", client_ip, list(payload.keys()))
        return web.json_response(
            {"jsonrpc": "2.0", "id": payload_id, "error": {"code": -32602, "message": "Missing 'method' or 'params' in request payload"}},
            status=400
        )

    if not isinstance(tool_arguments, Mapping):
        logger.warning("Invalid MCP request from %s: 'params' must be an object, got %s", client_ip, type(tool_arguments).__name__)
        return web.json_response(
            {"jsonrpc": "2.0", "id": payload_id, "error": {"code": -32602, "message": "'params' must be an object/dictionary"}},
            status=400
        )

    logger.info("MCP HTTP call received from %s: %s args_summary: %s", client_ip, tool_name, _redact_arguments(tool_arguments))

    try:
        result_contents = await call_tool(tool_name, tool_arguments)
    except Exception:
        logger.exception("Error while executing tool %s", tool_name)
        return web.json_response(
            {"jsonrpc": "2.0", "id": payload_id, "error": {"code": -32000, "message": f"Internal server error while executing tool {tool_name}"}},
            status=500
        )

    # Extract primary response
    response_data: Any = None
    if result_contents:
        first = result_contents[0]
        if isinstance(first, TextContent):
            try:
                response_data = json.loads(first.text)
            except Exception:
                response_data = first.text
        else:
            response_data = {"type": getattr(first, 'type', 'unknown')}
    
    # Wrap successful response in JSON-RPC 2.0 format
    return web.json_response(
        {"jsonrpc": "2.0", "id": payload_id, "result": response_data if response_data is not None else {}},
        status=200
    )


async def mcp_get_handler(request: web.Request):
    """HTTP handler for listing available tools at /mcp (JSON-RPC 2.0 compliant)."""
    client_ip = _get_client_ip(request)
    logger.info("MCP HTTP call received from %s: list_tools (GET /mcp)", client_ip)

    try:
        offerings = await _get_server_offerings()
        
        response_payload = {
            "jsonrpc": "2.0",
            "id": "list_tools_response", # Static ID for tool listing response
            "result": offerings
        }
        return web.json_response(response_payload, status=200)
    except Exception:
        logger.exception("Error while listing tools at GET /mcp")
        error_payload = {
            "jsonrpc": "2.0",
            "id": "list_tools_response",
            "error": {"code": -32000, "message": "Internal server error during tool listing"}
        }
        return web.json_response(error_payload, status=500)


async def list_tools_handler(request: web.Request):
    """HTTP handler for listing available tools (JSON-RPC 2.0 compliant)."""
    client_ip = _get_client_ip(request)
    logger.info("MCP HTTP call received from %s: list_tools (GET /mcp/tools)", client_ip)

    try:
        offerings = await _get_server_offerings()
        
        response_payload = {
            "jsonrpc": "2.0",
            "id": "list_tools_response", # Static ID for tool listing response
            "result": offerings
        }
        return web.json_response(response_payload, status=200)
    except Exception:
        logger.exception("Error while listing tools")
        error_payload = {
            "jsonrpc": "2.0",
            "id": "list_tools_response",
            "error": {"code": -32000, "message": "Internal server error during tool listing"}
        }
        return web.json_response(error_payload, status=500)


async def health_handler(request: web.Request):
    return web.json_response({"status": "ok"}, status=200)


async def main() -> None:
    await initialize()

    web_app = web.Application()
    web_app.router.add_get('/health', health_handler)
    web_app.router.add_post('/mcp', mcp_post_handler) # Use new handler for POST
    web_app.router.add_get('/mcp', mcp_get_handler) # New handler for GET /mcp
    web_app.router.add_get('/mcp/tools', list_tools_handler) # Keep existing route for /mcp/tools

    runner = web.AppRunner(web_app)
    await runner.setup()
    site = web.TCPSite(runner, host='0.0.0.0', port=9001)
    await site.start()

    logger.info("eMISTR MCP HTTP Server started on port 9001")

    try:
        while True:
            await asyncio.sleep(3600)
    except asyncio.CancelledError:
        logger.info("Shutdown requested, stopping server")
    finally:
        # Attempt DB disconnect
        try:
            disconnect = getattr(_db, 'disconnect', None)
            if disconnect:
                await disconnect()
        except Exception:
            logger.exception("Error while disconnecting DB")
        await runner.cleanup()


if __name__ == "__main__":
    asyncio.run(main())
